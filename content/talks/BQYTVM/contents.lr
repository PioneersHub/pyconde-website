title: Beyond Stateless: Why Your Web Service Architecture is Fighting Against Performance
---
created: 2025-12-06
---
code: BQYTVM
---
speaker_names: Heiner Wolf
---
speakers:


### Heiner Wolf

Heiner Wolf is a physicist and coder. After completing his Master’s degree in particle physics at CERN, he got a PhD in computer science and is now a passionate full stack developer (C#, TypeScript, Python). Heiner has been CTO for many years, in his own startups and those of others. Alongside all sorts of good stories, he enjoys realistic future scenarios and hard science fiction. And when triggered on physics, he’ll gladly rant about how fusion research should really be done.

---
abstract:

We've been told for years that stateless services are the holy grail of scalable web architectures. But what if this foundational principle is actually hurting both development velocity and runtime performance? This talk challenges the dominant paradigm by demonstrating how stateful, object-oriented programming can automatically scale to millions of users without the typical infrastructure complexity.

I'll show how keeping objects with their state in distributed memory eliminates the need for explicit caching strategies, reduces database bottlenecks, and dramatically simplifies your codebase. You'll see how a simple Python class can transparently scale across multiple servers, handling millions of concurrent users without implementing REST endpoints, message queues, or cache invalidation logic.

We'll examine why the historical evolution of web services created the myth that "stateless is good" and demonstrate an alternative where Python objects live persistently in a cluster, maintaining their state while the framework handles distribution, persistence, and failover automatically. Learn how to write Python code that scales from prototype to production using the same simple object-oriented patterns throughout.
---
full_description:

## The Problem Many Face

Every developer of a successful web service knows this progression: You start with a simple FastAPI or Django app. It works great locally. Then you deploy it, traffic grows, and suddenly you're working primarily on infrastructure complexity. Load balancers, cache layers, database replicas, message queues, and before you know it, your simple microservice based business logic has become a complex distributed system mesh including careful cache invalidation logic.

But what if this complexity isn't inevitable? What if it's actually the result of a historical mistake that became "best practice"?

## Challenging the Stateless Dogma

This talk challenges a fundamental assumption of modern web architecture: that stateless services are superior for scalability. I'll demonstrate that this belief, born from the constraints of early web servers, is now actively harmful to both performance and developer productivity. The truth is: separating logic from state (the core of stateless architecture) creates most of the complexity we fight daily. Every database query, every cache lookup, every message queue: they're all workarounds for the fact that we threw away our object's state after each request.

## Key Takeaways

- Stateless isn't a virtue, it's a workaround: modern systems can and should maintain state efficiently across requests.
- Your objects can be the cache: when objects persist in distributed memory, explicit caching becomes redundant.
- Scale by writing normal Python code: the same object-oriented patterns work from prototype to web-scale.
- Performance through simplicity: eliminating layers of infrastructure translation improves both latency and throughput.
- Focus on business logic, not plumbing: let the framework handle distribution, persistence, and failover.

## Who Should Attend

Python developers who:
- are building or maintaining web services,
- have experienced the pain of cache invalidation,
- want to scale without changing their programming model,
- are curious about alternatives to microservices.

## A Paradigm Shift

Just as we moved from manual memory management to garbage collection, it's time to move on from manual state management. Your Python objects should live as long as they're needed, not just for the duration of a request. This isn't theoretical. Systems using this approach power gaming platforms with millions of concurrent users, financial systems requiring microsecond latency, and IoT platforms managing billions of devices. The technology exists. We just need to unlearn the "stateless is good" mantra.
---
room: 
---
day: 
---
start_time: 
---
track: Programming & Software Engineering & Testing
---
python_skill: Intermediate
---
domain_expertise: Intermediate
---
social_card_image: /static/media/social/talks/BQYTVM.png


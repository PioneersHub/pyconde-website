title: Building a NoGIL Load Balancer in 30 minutes
---
created: 2024-12-17
---
code: GVFCG8
---
speaker_names: Alvaro Duran
---
abstract: Load balancers are widespread nowadays because most software systems are web centric and service oriented. However, they’re extremely complex to build, because they must be very performant and use sophisticated algorithms to route traffic. Until recently, you couldn’t use Python to build one, because even though it would make the code simpler, the GIL prevented multiple threads from executing Python at the same time.
Now that you can, what are the practical implications in your day to day work?
In this talk, we’re going to live code a load balancer in Python. This will help us understand the pros and cons of using modules such as asyncio, threading and concurrent.futures, and what changes when we remove the GIL from the way.
Whether you’re building systems that demand concurrency (such as AI models or DevOps pipelines), or you’re just curious about how tools like gUnicorn or Starlette work under the hood, you’ll come away with practical insights on how to start off the NoGIL era on the right foot.
---
description: You've already heard that Python is making the GIL optional, but still aren't sure why that matters to you? Do you think that live coding talks are thrilled to watch? Whether you're building systems that demand concurrency (such as AI models or DevOps pipelines), or you just want to see a risky act of live coding with threads, async and a pre-release version of Python, Building a NoGIL Load Balancer in 30 minutes is for you.

Load balancers are widespread nowadays because most software systems are web centric and service oriented. However, they’re extremely complex to build, because they must be very performant and use sophisticated algorithms to route traffic. Until recently, you couldn’t use Python to build one, because even though it would make the code simpler, the GIL prevented multiple threads from executing Python at the same time.
Now that you can, what are the practical implications in your day to day work?
In this talk, we’re going to live code a load balancer in Python. This will help us understand the pros and cons of using modules such as asyncio, threading and concurrent.futures, and what changes when we remove the GIL from the way.
Whether you’re building systems that demand concurrency (such as AI models or DevOps pipelines), or you’re just curious about how tools like gUnicorn or Starlette work under the hood, you’ll come away with practical insights on how to start off the NoGIL era on the right foot.

1. Introduction: the GIL, PEP 703, and why a load balancer is an ideal case study for NoGIL (5 min)
2. Load balancer 101 - Single thread, single client (3 min)
3. Introducing Threads, and load testing (5 min)
4. Let’s do asyncIO this time (5 min)
5. Stress testing (4 min)
7. Let's NoGIL and see what happens (6 min)
8. Takeaways (2 min)

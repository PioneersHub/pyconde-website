title: The Hidden Python Behind Every Typeface: Engineering Variable Fonts
---
created: 2025-11-21
---
code: TF7LQ7
---
speaker_names: Daksh P. Jain
---
speakers:


### Daksh P. Jain

Hey there! I'm Daksh, a freelance software engineer and product/visual designer who enjoys building products that feel simple, clear and human. I have spent the last six years working across backend systems, cloud tools, AI projects, frontend interfaces and product design. I like combining these areas to create end-to-end experiences where the engineering and the design support each other.

I have worked with startups, nonprofits and tech communities to build dashboards, tools and systems that are easy to use and easy to maintain. I care a lot about open source and community. I organize PyDelhi (New Delhi's Python user group) and have been helping with EuroPython since 2023, and I spend a good amount of time learning from the people around me.

Outside work, I read and write about psychology, sociology and philosophy. I like understanding how people think, feel and connect, and I try to bring that sensitivity into the things I build.

---
abstract:

Modern fonts look like static design assets, but they are actually complex software packages. Inside every `.ttf` and `.otf` file is a structured database of geometry, lookup tables, and rendering rules. The global type industry like Google Fonts, Adobe, and many independent foundries relies on Python to build, inspect, and automate these fonts.

This talk takes a practical, engineering-first look at how Python powers modern typography. Using the open-source FontTools library, I will show how glyphs are stored as contours and Bezier points, how font binaries can be decompiled into editable XML, and how changes can be compiled back into a working font. We will also look at the interpolation math that allows Variable Fonts to morph smoothly between weights such as Thin and Bold.

By the end, attendees will understand how Python fits into real font production pipelines and how these tools can automate or extend their own design and engineering work.
---
full_description:

Most developers treat fonts as opaque assets: a `.ttf` file goes into a static folder, and the operating system takes care of the rest. But modern OpenType fonts are not simple graphic files. They are highly structured software containers with coordinate geometry, lookup tables, metadata, and logic that controls shaping, layout, and rendering.

What many people do not know is that Python sits at the center of professional font engineering. The widely used FontTools library and its companions (`mutatorMath`, `ufoLib`, and others) form the backbone of pipelines at Google Fonts, Adobe, and many independent type foundries. These tools allow designers and engineers to inspect, manipulate, and build fonts using the same programming workflows we use for any other software system.

This talk introduces the engineering side of font technology using accessible, Python-centric examples. It focuses on how fonts actually work at the data level, why Python is the dominant language in this domain, and how simple scripts can reveal or modify the internals of a font.

### What the talk covers

**1. Fonts as Software**
OpenType files are not bitmaps or SVGs. They are binary containers made up of tables: `head`, `glyf`, `cmap`, `GSUB`, `GPOS`, and many others. Each table stores structured data such as glyph outlines, metrics, encodings, or layout rules. This section explains why thinking of fonts as software gives us new ways to work with them.

**2. The Anatomy of a Glyph**
Glyphs are defined as contours built from quadratic or cubic Bezier curves. I will show how these shapes are represented internally and how FontTools exposes them as Python objects. A short example demonstrates how to load a glyph, read its points, and render it for inspection.

**3. Working With FontTools**
FontTools can decompile OpenType binaries into TTX, a readable XML format. This gives engineers direct visibility into the tables and values inside a font. Through a small live demonstration, I will show how to dump a `.ttf`, modify a glyph or metric in XML or Python, and compile the font back into a working binary. This mirrors real workflows used in type design and QA.

**4. How Variable Fonts Work**
Variable Fonts introduce continuous axes such as Weight, Width, and Slant. Internally, they rely on interpolation. If you have two master designs (for example, Thin and Bold), you can compute intermediate shapes using a simple linear equation.
I will explain how this math works, how Python libraries implement it, and how deltas and variation tables store the information efficiently.

**5. Automation and Pipelines**
Finally, we look at how Python automates real tasks: generating kerning pairs, validating outlines, or building release fonts. This section shows how scripting can expand what designers and developers can do without manual editing tools.


### Takeaways

Attendees will learn:

* how OpenType fonts are structured and why they are software
* how glyphs and Bezier curves are represented internally
* how to inspect, modify, and rebuild fonts using FontTools
* the math behind Variable Font interpolation
* how Python scripts automate professional font production
---
room: 
---
day: 
---
start_time: 
---
track: Programming & Software Engineering & Testing
---
python_skill: Intermediate
---
domain_expertise: Intermediate
---
social_card_image: /static/media/social/talks/TF7LQ7.png

